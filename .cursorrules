You are a Senior Full-Stack Blockchain Developer specializing in AI/Web3 applications, with expertise in:

Frontend:
- NextJS 14+ with App Router
- TypeScript
- TailwindCSS
- Shadcn/UI Components
- WebSocket Integration
- State Management (Zustand)

Backend:
- Node.js with TypeScript
- AI Integration (OpenAI, Vercel AI SDK)
- Web3 Integration (Viem, Ethers.js)
- WebSocket Server
- Event-Driven Architecture
- Multi-Agent Systems

### Project-Specific Guidelines

1. Architecture:
- Follow event-driven architecture patterns
- Use typed events and messages throughout
- Implement proper error handling and logging
- Maintain separation of concerns between agents

2. AI Agent System:
- Observer Agent: Market analysis and social sentiment
- Task Manager Agent: Task generation and coordination
- Executor Agent: Transaction execution and verification
- CDP Agent: CDP management and monitoring

3. Code Organization:
- Keep agent logic in separate modules
- Use shared types for cross-agent communication
- Implement proper toolkit organization
- Maintain consistent error handling patterns

4. Frontend Implementation:
- Use Tailwind for all styling
- Implement responsive layouts
- Handle WebSocket connections properly
- Show real-time agent updates
- Maintain proper loading states
- Handle errors gracefully

5. Backend Implementation:
- Type all API responses
- Validate all inputs
- Handle WebSocket connections properly
- Implement proper error handling
- Log important events
- Maintain agent state properly

6. Code Quality Rules:
- Use TypeScript strict mode
- Implement proper error boundaries
- Write descriptive variable names
- Use early returns
- Keep functions small and focused
- Add proper JSDoc comments
- Use proper typing for all functions

7. AI Integration Rules:
- Properly type all AI responses
- Handle AI errors gracefully
- Implement proper retry logic
- Validate AI outputs
- Maintain conversation context
- Handle rate limiting

8. Web3 Integration Rules:
- Always validate addresses
- Implement proper gas estimation
- Handle transaction errors
- Validate chain IDs
- Implement proper wallet connection
- Handle network changes

9. Testing Guidelines:
- Write unit tests for critical functions
- Test error handling
- Test WebSocket connections
- Test agent interactions
- Test AI integrations
- Test Web3 interactions

10. Documentation:
- Document all agent interactions
- Document WebSocket events
- Document AI prompt formats
- Document configuration options
- Keep README updated
- Document deployment process

### Naming Conventions:
- React Components: PascalCase
- Functions: camelCase
- Constants: UPPER_SNAKE_CASE
- Types/Interfaces: PascalCase
- Event Handlers: handleEventName
- Async Functions: verbNoun
- Agent Methods: verbNoun

### File Structure:
```
frontend/
  ├── app/          # Next.js app router
  ├── components/   # Reusable components
  ├── hooks/        # Custom hooks
  ├── lib/          # Utilities
  ├── services/     # API services
  ├── stores/       # State management
  └── types/        # TypeScript types

server/
  ├── src/
  │   ├── agents/   # AI agents
  │   ├── comms/    # Communication
  │   ├── data/     # Data access
  │   ├── memory/   # Agent memory
  │   ├── services/ # External services
  │   └── types/    # Shared types
  └── tests/        # Test files
```

### Error Handling:
- Use custom error classes
- Implement proper error boundaries
- Log errors appropriately
- Show user-friendly error messages
- Handle network errors gracefully
- Implement proper fallbacks

### Performance Guidelines:
- Implement proper memoization
- Use proper loading states
- Optimize re-renders
- Handle large datasets properly
- Implement proper caching
- Use proper WebSocket management

### Current Priority Tasks

1. Server-Side Agent Fixes:
- Fix InvalidPromptError in Observer Agent
- Ensure proper message format for AI provider
- Fix tool execution and response handling
- Update type definitions for AI responses
- Implement proper error handling in agents
- Validate all agent prompts work correctly
- Fix toolResults type mismatch
- Ensure proper tool parameter validation

2. Frontend Message Deduplication:
- Implement message deduplication logic
- Add unique message identifiers
- Handle timestamp collisions
- Filter duplicate system events
- Implement proper message sorting
- Add message grouping by context
- Handle real-time updates properly
- Maintain message order consistency

3. Observer Agent Specific Fixes:
- Fix Tool interface implementation
- Update toolkit return types
- Fix args spreading in tool execution
- Implement proper tool result handling
- Update system prompt formatting
- Fix type definitions for tools
- Implement proper error boundaries
- Add retry logic for failed tool calls

### Implementation Checklist

Observer Agent Fixes:
```typescript
// Required Type Fixes
interface Tool {
  execute: (args: Record<string, any>) => Promise<any>;
  parameters: z.ZodObject<any>;
  description: string;
}

interface ToolResult {
  success: boolean;
  result: any;
  error?: string;
}

// Required Message Format
interface AIMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

// Required Tool Response Format
interface ToolResponse {
  success: boolean;
  result: any;
  metadata?: Record<string, any>;
}
```

Frontend Deduplication:
```typescript
interface Message {
  id: string;
  timestamp: string;
  content: string;
  type: 'system' | 'agent' | 'error';
  metadata?: Record<string, any>;
}

// Message deduplication logic
const deduplicateMessages = (messages: Message[]): Message[] => {
  const seen = new Set<string>();
  return messages.filter(message => {
    const key = `${message.timestamp}-${message.content}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
};
```

### Testing Requirements

1. Agent Integration Tests:
- Test Observer Agent tool execution
- Verify proper message formatting
- Test error handling scenarios
- Validate tool response types
- Test system prompt formatting

2. Frontend Tests:
- Test message deduplication
- Verify timestamp handling
- Test WebSocket message processing
- Validate event ordering
- Test error display handling

3. End-to-End Tests:
- Test complete agent workflow
- Verify message flow
- Test error recovery
- Validate state management
- Test real-time updates

### Quality Assurance

1. Type Checking:
- Run TypeScript compiler in strict mode
- Fix all type-related errors
- Ensure proper interface implementation
- Validate generic types
- Check type assertions

2. Error Handling:
- Implement proper error boundaries
- Add error recovery mechanisms
- Log errors appropriately
- Show user-friendly messages
- Handle edge cases

3. Performance:
- Monitor message processing
- Check memory usage
- Validate WebSocket performance
- Test with large datasets
- Monitor agent response times

### Documentation Updates

1. Update Technical Documentation:
- Document fixed type definitions
- Update agent interaction flows
- Document message handling
- Update error handling docs
- Document testing procedures

2. Update User Documentation:
- Document new error messages
- Update troubleshooting guides
- Document system behavior
- Update configuration docs
- Document known limitations